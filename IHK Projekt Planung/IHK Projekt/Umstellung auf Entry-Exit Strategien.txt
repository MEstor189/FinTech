ğŸ§¾ Zusammenfassung: Umstellung auf Entry- und Exit-Strategien
ğŸ¯ Ziel:
Die bisherige Strategy-Klasse wurde in zwei separate Strategie-Typen aufgeteilt:

Strategieart	Zweck	Beispiel
EntryStrategy	Wann wird gekauft?	BuyTheDipEntryStrategy
ExitStrategy	Wann wird verkauft?	TargetProfitExitStrategy

Diese Trennung macht dein System flexibler, realistischer und modularer.

ğŸ“ Neue Struktur:
plaintext
Kopieren
Bearbeiten
engine/
â””â”€â”€ strategy/
    â”œâ”€â”€ entry/
    â”‚   â”œâ”€â”€ EntryStrategy.java
    â”‚   â”œâ”€â”€ BuyTheDipEntryStrategy.java
    â”‚   â””â”€â”€ EntryStrategyFactory.java
    â”œâ”€â”€ exit/
    â”‚   â”œâ”€â”€ ExitStrategy.java
    â”‚   â”œâ”€â”€ TargetProfitExitStrategy.java
    â”‚   â””â”€â”€ ExitStrategyFactory.java
    â””â”€â”€ enums/
        â”œâ”€â”€ EntryStrategyType.java
        â””â”€â”€ ExitStrategyType.java
ğŸ”§ Zentrale Interfaces
EntryStrategy.java
java
Kopieren
Bearbeiten
boolean shouldEnter(StockData data);
ExitStrategy.java
java
Kopieren
Bearbeiten
boolean shouldExit(StockData data, Portfolio portfolio);
ğŸ› ï¸ Wichtige Klassen
BuyTheDipEntryStrategy
Einstieg, wenn der Vortagspreis um â‰¥â€¯dipThreshold gefallen ist

TargetProfitExitStrategy
Verkauf, wenn aktuelle Position â‰¥â€¯profitTarget erreicht

ğŸ§  Neue Factories
EntryStrategyFactory.createEntryStrategy(...)
Baut eine Entry-Strategie anhand von Typ + Parametern

ExitStrategyFactory.createExitStrategy(...)
Baut eine Exit-Strategie anhand von Typ + Parametern

ğŸ§¾ DTO (Request)
Beispielstruktur SimulationRequest:
json
Kopieren
Bearbeiten
{
  "entryStrategyType": "BUY_THE_DIP",
  "exitStrategyType": "TARGET_PROFIT",
  "entryParams": { "dipThreshold": 3.0 },
  "exitParams": { "profitTarget": 5.0 }
}
ğŸ” Neuer Ablauf in SimulationEngine
java
Kopieren
Bearbeiten
if (entryStrategy.shouldEnter(today)) {
    // Position kaufen
}

if (exitStrategy.shouldExit(today, portfolio)) {
    // Alle offenen Positionen verkaufen
}
âœ… Vorteile der Umstellung
Kombinierbarkeit von Strategien (z.â€¯B. BuyTheDip + MovingAverage)

Einheitliches Designprinzip

Leichtere Erweiterbarkeit

Sauberere Architektur â†’ prÃ¼ferfreundlich














ğŸ“„ Architekturanpassung: Trennung von Kauf- und Verkaufsstrategien
Im Verlauf des Projekts wurde die Architektur der Handelsstrategien modularisiert, um mehr FlexibilitÃ¤t, Wartbarkeit und RealitÃ¤tsnÃ¤he zu erreichen.
Anstatt eine monolithische Strategieklasse zu verwenden, wurde das System so umgebaut, dass Einstiegs- und Ausstiegsentscheidungen getrennt behandelt werden.

ğŸ¯ Ziel der Umstellung
Die ursprÃ¼ngliche Strategy-Schnittstelle, die sowohl Einstieg (shouldEnter) als auch Ausstieg (shouldExit) definierte, wurde aufgeteilt in:

EntryStrategy: definiert die Logik, wann eine neue Position erÃ¶ffnet wird.

ExitStrategy: entscheidet, wann eine Position geschlossen werden soll.

Dadurch kÃ¶nnen verschiedene Kombinationen von Kauf- und Verkaufsstrategien flexibel zusammengesetzt und in der Simulation verwendet werden.

ğŸ”§ Technische Umsetzung
Neue Interfaces:
EntryStrategy: enthÃ¤lt die Methode shouldEnter(StockData data)

ExitStrategy: enthÃ¤lt die Methode shouldExit(StockData data, Portfolio portfolio)

Beispielimplementierungen:
BuyTheDipEntryStrategy: Einstieg bei starkem KursrÃ¼ckgang gegenÃ¼ber dem Vortag.

TargetProfitExitStrategy: Verkauf bei Erreichen eines definierten Gewinnziels.

Strategie-Factories
Zwei separate Factory-Klassen wurden eingefÃ¼hrt:

EntryStrategyFactory

ExitStrategyFactory

Diese erzeugen jeweils die passende Strategieinstanz basierend auf einem enum-Typ und einem Parametersatz (Map<String, Double>).
So kann Ã¼ber die API definiert werden, welche Strategietypen genutzt und welche Schwellenwerte gesetzt werden sollen.

API-Anpassung
Der SimulationRequest-DTO wurde erweitert um:

entryStrategyType, exitStrategyType

entryParams, exitParams

Beispiel:

json
Kopieren
Bearbeiten
{
  "entryStrategyType": "BUY_THE_DIP",
  "exitStrategyType": "TARGET_PROFIT",
  "entryParams": { "dipThreshold": 3.0 },
  "exitParams": { "profitTarget": 5.0 }
}
Engine-Anpassung
Die SimulationEngine verwendet nun zwei separate Strategieobjekte:

java
Kopieren
Bearbeiten
EntryStrategy entryStrategy;
ExitStrategy exitStrategy;
Diese werden im Simulationsablauf getrennt aufgerufen:

shouldEnter(...) â†’ neue Position wird erÃ¶ffnet

shouldExit(...) â†’ alle offenen Positionen werden geschlossen

âœ… Vorteile der Umstellung
ModularitÃ¤t: Einstieg und Ausstieg kÃ¶nnen unabhÃ¤ngig voneinander erweitert und getestet werden

FlexibilitÃ¤t: Beliebige Kombinationen aus Strategien sind mÃ¶glich

Erweiterbarkeit: Neue Strategiearten kÃ¶nnen leicht hinzugefÃ¼gt werden, ohne bestehende Klassen zu verÃ¤ndern

Benutzerfreundlichkeit: SpÃ¤ter kann der Benutzer Ã¼ber das Frontend Strategien frei zusammenstellen
