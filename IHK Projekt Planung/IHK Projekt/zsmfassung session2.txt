ğŸ§¾ Projekt-Zusammenfassung â€“ Session: Exit-Strategien & Architekturentscheidungen
Projekt: Simulationsengine fÃ¼r Handelsstrategien
Technologie: Java, Spring Boot, React, MySQL, Alpaca API
Kontext: Strategie-Modul im Backend â€“ Entry- und Exit-Logik fÃ¼r Simulationen

âœ… Ziel der Session
Erweiterung der Simulationsengine um mindestens zwei Exit-Strategien, die sowohl Gewinnrealisierung als auch realistische Logik abbilden.
Ziel war zudem saubere Architektur, Wiederverwendbarkeit und Vorbereitung fÃ¼r Dokumentation und Wartbarkeit.

ğŸ” Bereits vorhanden
Entry-Strategien:

BuyTheDipEntry

MovingAverageEntry

MomentumEntry

Exit-Strategien:

TargetProfitExit (Basis)

Globale Exit-Logik:
Sobald eine Position das Exit-Kriterium erfÃ¼llt â†’ alle Positionen werden geschlossen (aus Engine-Summary bekannt)

âœ… Neu erstellte Exit-Strategien
1. TrailingStopExit
Position wird geschlossen, sobald Kurs um Xâ€¯% vom bisherigen Maximum seit Kauf gefallen ist.

Wichtige Elemente:

java
Kopieren
Bearbeiten
double stopPrice = maxPrice * (1 - trailingStopPercent);
if (currentClose <= stopPrice) {
    return true;
}
updateMaxPrice() wird direkt in shouldExit(...) aufgerufen, um die Engine universell zu halten

Simulation wurde angepasst auf parallele KÃ¤ufe + globales Exit

Realistische Ergebnisse bei AAPL-Testdaten erzielt

2. MovingAverageCrossExit
Exit bei Crossover von gleitenden Durchschnitten â€“ z.â€¯B. MA(3) fÃ¤llt unter MA(10)

Logik:

java
Kopieren
Bearbeiten
return shortMA_yesterday >= longMA_yesterday
    && shortMA_today < longMA_today;
Parameter per JSON:

json
Kopieren
Bearbeiten
"exitStrategyType": "MOVING_AVERAGE_CROSS",
"exitParams": {
  "shortPeriod": 3,
  "longPeriod": 10
}
ğŸ”§ Ãœberarbeitung der Entry-Strategie MovingAverageEntry
Die lokale Methode calculateAverage(...) wurde durch die gemeinsame MovingAverageUtil.calculateAverage(...) ersetzt

Robuste Berechnung inkl. Sortierung und Fallback bei fehlenden Daten

Nutzung von getPreviousTradingDay(...) statt minusDays(1) fÃ¼r saubere Handelstag-Logik

ğŸ› ï¸ Utility-Klassen â€“ Status & Entscheidung
Diskussion & Brainstorming gefÃ¼hrt, aber:

Aktuell keine Utility-Klassen notwendig, da keine Redundanz besteht.
Entscheidung: erst auslagern, wenn Code mehrfach auftritt

Geplante Helfer bei Bedarf:

ProzentÃ¤nderung: percentChange(from, to)

Crossover-Logik: hasCrossover(...)

Gleitende Durchschnitte: calculateAverage(...)

Handelstagsfilterung: getNthTradingDayBefore(...)

ğŸ”¬ Tests & Simulation
AAPL-Kursdaten vom 01.07.2024 bis 01.01.2025 getestet

Simulation angepasst:

Parallele KÃ¤ufe erlaubt

Verkauf aller Positionen bei Exit-Trigger

Beispiel-Trade-Logik erfolgreich validiert gegen reale Simulations-Response

ğŸ“„ Beispiel-Request (Body)
json
Kopieren
Bearbeiten
{
  "symbol": "AAPL",
  "startDate": "2024-07-01",
  "endDate": "2025-01-01",
  "entryStrategyType": "MOVING_AVERAGE",
  "exitStrategyType": "MOVING_AVERAGE_CROSS",
  "entryParams": {
    "shortPeriod": 2,
    "longPeriod": 3
  },
  "exitParams": {
    "shortPeriod": 3,
    "longPeriod": 10
  },
  "investmentPerTrade": 100.0
}
ğŸ§  Architekturentscheidungen & Best Practices
Strategien sollen rein sein (keine AbhÃ¤ngigkeit zur Engine oder anderen Services)

Portfolio verwaltet maxPrice je Position

shouldExit(...) darf ZustÃ¤nde anpassen, z.â€¯B. maxPrice aktualisieren

Utilitys werden nur gebaut, wenn sich Wiederholung konkret ergibt

MovingAverageUtil korrekt nach Bedarf modularisiert

ğŸ”š Aktueller Stand (Session-Ende)
Zwei zusÃ¤tzliche Exit-Strategien implementiert, getestet und integriert

Einheitliche, robuste MA-Berechnung fÃ¼r Entry & Exit

Utility-Vorbereitung durchgefÃ¼hrt, aber bewusst zurÃ¼ckgestellt

Projekt ist einsatzbereit fÃ¼r weitere Strategien, Backtests oder Auswertungen